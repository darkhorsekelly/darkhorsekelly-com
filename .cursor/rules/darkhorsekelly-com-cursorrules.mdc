---
alwaysApply: true
---

# Dark Horse Kelly - "Generalist's Notebook" Project Rule

This rule defines the specific technical patterns and library usage for the "Generalist's Notebook" project. It complements the global TDD and spec-referencing rules by providing the "how-to" for this specific codebase.

Andrew's philosophy is a two-pass approach between the Cursor agent and the human (Andrew). The below rules support this approach. 

---

## 1. Core Technology Stack

- **Framework**: Next.js (App Router)
- **Language**: TypeScript
- **Database**: Prisma PostgreSQL (hosted by Prisma and linked to Vercel)
- **ORM**: Prisma
- **Authentication**: NextAuth.js
- **Styling**: Tailwind CSS (Minimal Use - See Section 6)
- **Content**: Local MDX files (`.mdx`)
- **Testing**: Jest with React Testing Library (Unit/Component), Playwright (E2E)

---

## 2. Data & Server-Side Logic

All data logic must be type-safe and executed on the server. Do not create a separate API layer.

### a. Database Access & Mutations
- **Prisma Exclusivity**: All database queries and mutations **must** use the **Prisma** client. The Prisma client must only be imported and used in server-side files (Server Components or Server Actions).
- **Server Actions for Mutations**: All database writes (create, update, delete) **must** be handled via **Server Actions**. Define these in `app/lib/actions.ts` or directly within the Server Component that uses them.

### b. Data Validation
- **Zod Enforcement**: All data from forms or external sources **must** be validated with a **Zod** schema within the Server Action *before* being passed to Prisma.
- **Schema Location**: Define Zod schemas in `app/lib/schemas.ts`.

### c. Error Handling
- **Error Handling**: All Server Actions that perform database operations or external API calls must be wrapped in a try...catch block. In the catch block, log the specific error to the console for debugging and return a generic, user-friendly error message (e.g., { message: 'Database Error: Failed to perform action.' }).

---

## 3. Component & UI Development

- **Server Components by Default**: All components must be React Server Components unless they require hooks (`useState`, `useEffect`) or event listeners (`onClick`). Only then should you use the `'use client'` directive.
- **Data Fetching**: Data should be fetched directly in Server Components by `await`-ing Prisma calls. Do not fetch data in `useEffect` hooks.
- **Styling**: Adhere strictly to the "Function Over Form" philosophy outlined in Section 6.
- **File Naming Conventions**: React component files and directories must use PascalCase (e.g., /ui/ProjectTracker.tsx). Non-component files (actions, schemas, utilities) must use kebab-case (e.g., /lib/server-actions.ts). Each component must be in its own file.
- **Code Documentation**: Any non-trivial function, Server Action, or component with multiple props must include a TSDoc comment block explaining its purpose, parameters (@param), and return value (@returns).


---

## 4. Content Management (Artifacts)

- **Source**: All primary content (`Dev Log`, `Blog Post`) must be stored as `.mdx` files in the `/content` directory.
- **Frontmatter Requirement**: Every `.mdx` file must contain a YAML frontmatter block with the following keys: `title`, `publish_date`, `is_featured`, `project_ids`, and `tag_ids` [cite: 35-39].
- **Parsing & Rendering**: Use **`gray-matter`** to parse frontmatter and **`next-mdx-remote`** to render the content itself.

---

## 5. Testing Implementation

Your global rule mandates a TDD workflow. This section specifies the tools to use for that workflow.

- **Unit & Component Tests**: Use **Jest** with **React Testing Library**.
- **End-to-End (E2E) Tests**: Use **Playwright** for critical user flows like form submissions and navigation.

---

## 6. UI & Styling Philosophy ("Function Over Form")

This is the most critical rule for UI generation. The goal is to produce functional, "headless" scaffolding that you will style later.

- **Use Unstyled, Semantic HTML**: Default to plain, semantic HTML elements (`<button>`, `<input>`, `<h2>`, `<section>`). Do not use `<div>` when a more specific tag is appropriate.
- **Forbid Decorative Styling**: **Do not** use any decorative Tailwind CSS classes. This includes colors (`bg-blue-500`, `text-gray-900`), shadows (`shadow-md`), borders (`border`, `rounded-lg`), padding (`p-4`), and margins (`m-2`). The generated UI should be "ugly" but functional.
- **Allow Minimal Layout Utilities**: The only permitted Tailwind CSS classes are for essential layout and structure: `flex`, `grid`, `flex-col`, `grid-cols-*`, `gap-*`, `items-*`, and `justify-*`. Use these only when necessary to make the layout functional.
- **Strict Componentization**: Any UI element that could be reused (button, input, card, modal) **must** be created as a separate, unstyled component in the `app/ui/` directory. These components should accept all necessary props for their logic but contain no decorative styling.
- **Define Prop Contracts**: Every component **must** have a TypeScript `interface` defining its props. This ensures the component's functionality is clear and correct, even without styling.

## 7. Accessibility (a11y) First

The underlying HTML structure should be accessible from the very beginning. The functional scaffolding needs to be usable by screen readers and keyboard navigation from the start. 

- **Semantic HTML**: Use semantic HTML elements (`<nav>`, `<main>`, `<button>`) instead of generic `<div>` tags wherever appropriate.
- **Form Labels**: Every `<input>`, `<select>`, and `<textarea>` element must have an associated `<label>` with a htmlFor attribute.
- **Keyboard Navigation**: All interactive elements (buttons, links) must be focusable and operable via the keyboard. Do not create onClick handlers on non-interactive elements like `<div>`.